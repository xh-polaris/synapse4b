// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"github.com/xh-polaris/synapse4b/biz/domain/basicuser/dal/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newBasicUser(db *gorm.DB, opts ...gen.DOOption) basicUser {
	_basicUser := basicUser{}

	_basicUser.basicUserDo.UseDB(db, opts...)
	_basicUser.basicUserDo.UseModel(&model.BasicUser{})

	tableName := _basicUser.basicUserDo.TableName()
	_basicUser.ALL = field.NewAsterisk(tableName)
	_basicUser.ID = field.NewField(tableName, "id")
	_basicUser.SchoolID = field.NewField(tableName, "school_id")
	_basicUser.Code = field.NewString(tableName, "code")
	_basicUser.Phone = field.NewString(tableName, "phone")
	_basicUser.Password = field.NewString(tableName, "password")
	_basicUser.Name = field.NewString(tableName, "name")
	_basicUser.Gender = field.NewUint8(tableName, "gender")
	_basicUser.Extra = field.NewField(tableName, "extra")
	_basicUser.CreatedAt = field.NewInt64(tableName, "created_at")
	_basicUser.UpdatedAt = field.NewInt64(tableName, "updated_at")
	_basicUser.DeletedAt = field.NewField(tableName, "deleted_at")

	_basicUser.fillFieldMap()

	return _basicUser
}

type basicUser struct {
	basicUserDo basicUserDo

	ALL       field.Asterisk
	ID        field.Field
	SchoolID  field.Field
	Code      field.String
	Phone     field.String
	Password  field.String // Password (Encrypted)
	Name      field.String // User Nickname
	Gender    field.Uint8
	Extra     field.Field
	CreatedAt field.Int64
	UpdatedAt field.Int64
	DeletedAt field.Field

	fieldMap map[string]field.Expr
}

func (b basicUser) Table(newTableName string) *basicUser {
	b.basicUserDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b basicUser) As(alias string) *basicUser {
	b.basicUserDo.DO = *(b.basicUserDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *basicUser) updateTableName(table string) *basicUser {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewField(table, "id")
	b.SchoolID = field.NewField(table, "school_id")
	b.Code = field.NewString(table, "code")
	b.Phone = field.NewString(table, "phone")
	b.Password = field.NewString(table, "password")
	b.Name = field.NewString(table, "name")
	b.Gender = field.NewUint8(table, "gender")
	b.Extra = field.NewField(table, "extra")
	b.CreatedAt = field.NewInt64(table, "created_at")
	b.UpdatedAt = field.NewInt64(table, "updated_at")
	b.DeletedAt = field.NewField(table, "deleted_at")

	b.fillFieldMap()

	return b
}

func (b *basicUser) WithContext(ctx context.Context) IBasicUserDo {
	return b.basicUserDo.WithContext(ctx)
}

func (b basicUser) TableName() string { return b.basicUserDo.TableName() }

func (b basicUser) Alias() string { return b.basicUserDo.Alias() }

func (b basicUser) Columns(cols ...field.Expr) gen.Columns { return b.basicUserDo.Columns(cols...) }

func (b *basicUser) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *basicUser) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 11)
	b.fieldMap["id"] = b.ID
	b.fieldMap["school_id"] = b.SchoolID
	b.fieldMap["code"] = b.Code
	b.fieldMap["phone"] = b.Phone
	b.fieldMap["password"] = b.Password
	b.fieldMap["name"] = b.Name
	b.fieldMap["gender"] = b.Gender
	b.fieldMap["extra"] = b.Extra
	b.fieldMap["created_at"] = b.CreatedAt
	b.fieldMap["updated_at"] = b.UpdatedAt
	b.fieldMap["deleted_at"] = b.DeletedAt
}

func (b basicUser) clone(db *gorm.DB) basicUser {
	b.basicUserDo.ReplaceConnPool(db.Statement.ConnPool)
	return b
}

func (b basicUser) replaceDB(db *gorm.DB) basicUser {
	b.basicUserDo.ReplaceDB(db)
	return b
}

type basicUserDo struct{ gen.DO }

type IBasicUserDo interface {
	gen.SubQuery
	Debug() IBasicUserDo
	WithContext(ctx context.Context) IBasicUserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IBasicUserDo
	WriteDB() IBasicUserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IBasicUserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IBasicUserDo
	Not(conds ...gen.Condition) IBasicUserDo
	Or(conds ...gen.Condition) IBasicUserDo
	Select(conds ...field.Expr) IBasicUserDo
	Where(conds ...gen.Condition) IBasicUserDo
	Order(conds ...field.Expr) IBasicUserDo
	Distinct(cols ...field.Expr) IBasicUserDo
	Omit(cols ...field.Expr) IBasicUserDo
	Join(table schema.Tabler, on ...field.Expr) IBasicUserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IBasicUserDo
	RightJoin(table schema.Tabler, on ...field.Expr) IBasicUserDo
	Group(cols ...field.Expr) IBasicUserDo
	Having(conds ...gen.Condition) IBasicUserDo
	Limit(limit int) IBasicUserDo
	Offset(offset int) IBasicUserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IBasicUserDo
	Unscoped() IBasicUserDo
	Create(values ...*model.BasicUser) error
	CreateInBatches(values []*model.BasicUser, batchSize int) error
	Save(values ...*model.BasicUser) error
	First() (*model.BasicUser, error)
	Take() (*model.BasicUser, error)
	Last() (*model.BasicUser, error)
	Find() ([]*model.BasicUser, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BasicUser, err error)
	FindInBatches(result *[]*model.BasicUser, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.BasicUser) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IBasicUserDo
	Assign(attrs ...field.AssignExpr) IBasicUserDo
	Joins(fields ...field.RelationField) IBasicUserDo
	Preload(fields ...field.RelationField) IBasicUserDo
	FirstOrInit() (*model.BasicUser, error)
	FirstOrCreate() (*model.BasicUser, error)
	FindByPage(offset int, limit int) (result []*model.BasicUser, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IBasicUserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (b basicUserDo) Debug() IBasicUserDo {
	return b.withDO(b.DO.Debug())
}

func (b basicUserDo) WithContext(ctx context.Context) IBasicUserDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b basicUserDo) ReadDB() IBasicUserDo {
	return b.Clauses(dbresolver.Read)
}

func (b basicUserDo) WriteDB() IBasicUserDo {
	return b.Clauses(dbresolver.Write)
}

func (b basicUserDo) Session(config *gorm.Session) IBasicUserDo {
	return b.withDO(b.DO.Session(config))
}

func (b basicUserDo) Clauses(conds ...clause.Expression) IBasicUserDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b basicUserDo) Returning(value interface{}, columns ...string) IBasicUserDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b basicUserDo) Not(conds ...gen.Condition) IBasicUserDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b basicUserDo) Or(conds ...gen.Condition) IBasicUserDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b basicUserDo) Select(conds ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b basicUserDo) Where(conds ...gen.Condition) IBasicUserDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b basicUserDo) Order(conds ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b basicUserDo) Distinct(cols ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b basicUserDo) Omit(cols ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b basicUserDo) Join(table schema.Tabler, on ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b basicUserDo) LeftJoin(table schema.Tabler, on ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b basicUserDo) RightJoin(table schema.Tabler, on ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b basicUserDo) Group(cols ...field.Expr) IBasicUserDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b basicUserDo) Having(conds ...gen.Condition) IBasicUserDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b basicUserDo) Limit(limit int) IBasicUserDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b basicUserDo) Offset(offset int) IBasicUserDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b basicUserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IBasicUserDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b basicUserDo) Unscoped() IBasicUserDo {
	return b.withDO(b.DO.Unscoped())
}

func (b basicUserDo) Create(values ...*model.BasicUser) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b basicUserDo) CreateInBatches(values []*model.BasicUser, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b basicUserDo) Save(values ...*model.BasicUser) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b basicUserDo) First() (*model.BasicUser, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.BasicUser), nil
	}
}

func (b basicUserDo) Take() (*model.BasicUser, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.BasicUser), nil
	}
}

func (b basicUserDo) Last() (*model.BasicUser, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.BasicUser), nil
	}
}

func (b basicUserDo) Find() ([]*model.BasicUser, error) {
	result, err := b.DO.Find()
	return result.([]*model.BasicUser), err
}

func (b basicUserDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BasicUser, err error) {
	buf := make([]*model.BasicUser, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b basicUserDo) FindInBatches(result *[]*model.BasicUser, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b basicUserDo) Attrs(attrs ...field.AssignExpr) IBasicUserDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b basicUserDo) Assign(attrs ...field.AssignExpr) IBasicUserDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b basicUserDo) Joins(fields ...field.RelationField) IBasicUserDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b basicUserDo) Preload(fields ...field.RelationField) IBasicUserDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b basicUserDo) FirstOrInit() (*model.BasicUser, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.BasicUser), nil
	}
}

func (b basicUserDo) FirstOrCreate() (*model.BasicUser, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.BasicUser), nil
	}
}

func (b basicUserDo) FindByPage(offset int, limit int) (result []*model.BasicUser, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b basicUserDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b basicUserDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b basicUserDo) Delete(models ...*model.BasicUser) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *basicUserDo) withDO(do gen.Dao) *basicUserDo {
	b.DO = *do.(*gen.DO)
	return b
}
